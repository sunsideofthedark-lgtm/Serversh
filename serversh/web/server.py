#!/usr/bin/env python3
"""
ServerSH Web UI Server
Lightweight web server for server management and configuration
"""

import os
import sys
import json
import yaml
import secrets
import hashlib
import subprocess
import logging
from datetime import datetime, timedelta
from pathlib import Path
from functools import wraps
from typing import Dict, List, Optional, Any

try:
    from flask import Flask, request, jsonify, session, render_template, send_file, redirect, url_for, flash
    from flask_cors import CORS
    import werkzeug.security
except ImportError as e:
    print(f"Missing required Python packages: {e}")
    print("Install with: pip install flask flask-cors werkzeug")
    sys.exit(1)

# Add ServerSH root to Python path
SERVERSH_ROOT = Path(__file__).parent.parent.parent
sys.path.insert(0, str(SERVERSH_ROOT))

# Configuration
app = Flask(__name__)
app.secret_key = os.environ.get('FLASK_SECRET_KEY', secrets.token_hex(32))
CORS(app)

# Logging setup
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('/var/log/serversh/web-ui.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# ServerSH Configuration
SERVERSH_CONFIG_DIR = os.environ.get('SERVERSH_CONFIG_DIR', '/etc/serversh')
SERVERSH_ROOT_DIR = os.environ.get('SERVERSH_ROOT', '/opt/serversh')
ENV_FILE = os.environ.get('SERVERSH_ENV_FILE', f'{SERVERSH_ROOT_DIR}/.env')

class ServerSHManager:
    """Main ServerSH management class"""

    def __init__(self):
        self.config_dir = Path(SERVERSH_CONFIG_DIR)
        self.root_dir = Path(SERVERSH_ROOT_DIR)
        self.env_file = Path(ENV_FILE)

    def load_env_config(self) -> Dict[str, str]:
        """Load configuration from .env file"""
        config = {}
        if self.env_file.exists():
            with open(self.env_file, 'r') as f:
                for line in f:
                    line = line.strip()
                    if line and not line.startswith('#') and '=' in line:
                        key, value = line.split('=', 1)
                        config[key.strip()] = value.strip()
        return config

    def save_env_config(self, config: Dict[str, str]) -> bool:
        """Save configuration to .env file"""
        try:
            # Create backup
            if self.env_file.exists():
                backup_file = self.env_file.with_suffix(f'.bak.{datetime.now().strftime("%Y%m%d_%H%M%S")}')
                self.env_file.rename(backup_file)

            # Save new configuration
            with open(self.env_file, 'w') as f:
                f.write(f"# ServerSH Configuration\n")
                f.write(f"# Generated by Web UI at {datetime.now().isoformat()}\n\n")

                for key, value in sorted(config.items()):
                    f.write(f"{key}={value}\n")

            return True
        except Exception as e:
            logger.error(f"Failed to save configuration: {e}")
            return False

    def get_modules(self) -> List[Dict[str, Any]]:
        """Get available modules"""
        modules = []
        modules_dir = self.root_dir / 'serversh' / 'modules'

        if modules_dir.exists():
            for category in modules_dir.iterdir():
                if category.is_dir():
                    for module_file in category.glob('*.sh'):
                        module_name = f"{category.name}/{module_file.stem}"

                        # Extract module metadata
                        metadata = self._extract_module_metadata(module_file)
                        metadata['name'] = module_name
                        metadata['category'] = category.name
                        metadata['file'] = str(module_file)

                        modules.append(metadata)

        return modules

    def _extract_module_metadata(self, module_file: Path) -> Dict[str, Any]:
        """Extract metadata from module file"""
        metadata = {
            'version': '1.0.0',
            'description': 'No description available',
            'dependencies': []
        }

        try:
            with open(module_file, 'r') as f:
                content = f.read()

                # Extract metadata variables
                for line in content.split('\n'):
                    line = line.strip()
                    if line.startswith('MODULE_VERSION='):
                        metadata['version'] = line.split('=', 1)[1].strip('"\'')
                    elif line.startswith('MODULE_DESCRIPTION='):
                        metadata['description'] = line.split('=', 1)[1].strip('"\'')
                    elif line.startswith('MODULE_DEPENDENCIES='):
                        deps = line.split('=', 1)[1].strip('"\'()')
                        if deps:
                            metadata['dependencies'] = [d.strip() for d in deps.split(',')]
        except Exception as e:
            logger.warning(f"Failed to extract metadata from {module_file}: {e}")

        return metadata

    def execute_module(self, module_name: str, action: str, config: Dict[str, str] = None) -> Dict[str, Any]:
        """Execute module action"""
        try:
            # Prepare environment
            env = os.environ.copy()
            if config:
                env.update(config)

            # Find module file
            modules_dir = self.root_dir / 'serversh' / 'modules'
            module_file = modules_dir / module_name.replace('/', '/') / f"{module_name.split('/')[-1]}.sh"

            if not module_file.exists():
                return {'success': False, 'error': f'Module file not found: {module_file}'}

            # Execute module
            result = subprocess.run(
                ['bash', str(module_file), action],
                capture_output=True,
                text=True,
                env=env,
                timeout=300  # 5 minute timeout
            )

            return {
                'success': result.returncode == 0,
                'stdout': result.stdout,
                'stderr': result.stderr,
                'returncode': result.returncode
            }

        except subprocess.TimeoutExpired:
            return {'success': False, 'error': 'Module execution timed out'}
        except Exception as e:
            return {'success': False, 'error': str(e)}

    def get_system_info(self) -> Dict[str, Any]:
        """Get system information"""
        try:
            # Basic system info
            with open('/etc/os-release', 'r') as f:
                os_info = {}
                for line in f:
                    if '=' in line:
                        key, value = line.strip().split('=', 1)
                        os_info[key] = value.strip('"')

            # Hardware info
            hostname = subprocess.check_output(['hostname'], text=True).strip()
            uptime = subprocess.check_output(['uptime', '-p'], text=True).strip()

            # Disk usage
            disk_usage = subprocess.check_output(['df', '-h', '/'], text=True).strip().split('\n')[-1]

            # Memory info
            with open('/proc/meminfo', 'r') as f:
                mem_info = {}
                for line in f:
                    if ':' in line:
                        key, value = line.strip().split(':', 1)
                        mem_info[key] = value.strip()

            return {
                'hostname': hostname,
                'os': os_info,
                'uptime': uptime,
                'disk_usage': disk_usage,
                'memory_total': mem_info.get('MemTotal', ''),
                'memory_available': mem_info.get('MemAvailable', ''),
                'serversh_version': '2.0.0',
                'python_version': sys.version,
                'timestamp': datetime.now().isoformat()
            }

        except Exception as e:
            logger.error(f"Failed to get system info: {e}")
            return {'error': str(e)}

# Initialize ServerSH manager
serversh = ServerSHManager()

def require_auth(f):
    """Decorator to require authentication"""
    @wraps(f)
    def decorated(*args, **kwargs):
        if 'authenticated' not in session:
            return jsonify({'error': 'Authentication required'}), 401
        return f(*args, **kwargs)
    return decorated

# Authentication Routes
@app.route('/api/auth/login', methods=['POST'])
def login():
    """Authenticate with system root credentials"""
    try:
        data = request.get_json()
        username = data.get('username')
        password = data.get('password')

        if not username or not password:
            return jsonify({'error': 'Username and password required'}), 400

        # Check if user is root
        if username != 'root':
            return jsonify({'error': 'Only root login is allowed'}), 401

        # Verify root password using /bin/su
        try:
            result = subprocess.run(
                ['su', '-c', 'echo success', 'root'],
                input=password + '\n',
                capture_output=True,
                text=True,
                timeout=10
            )

            if result.returncode == 0 and 'success' in result.stdout:
                session['authenticated'] = True
                session['username'] = username
                session.permanent = True
                app.permanent_session_lifetime = timedelta(hours=8)

                logger.info(f"Successful login for {username} from {request.remote_addr}")
                return jsonify({'success': True, 'message': 'Authentication successful'})
            else:
                logger.warning(f"Failed login attempt for {username} from {request.remote_addr}")
                return jsonify({'error': 'Invalid credentials'}), 401

        except subprocess.TimeoutExpired:
            return jsonify({'error': 'Authentication timeout'}), 401

    except Exception as e:
        logger.error(f"Login error: {e}")
        return jsonify({'error': 'Authentication failed'}), 500

@app.route('/api/auth/logout', methods=['POST'])
def logout():
    """Logout user"""
    session.clear()
    return jsonify({'success': True, 'message': 'Logged out successfully'})

@app.route('/api/auth/status', methods=['GET'])
def auth_status():
    """Check authentication status"""
    return jsonify({
        'authenticated': 'authenticated' in session,
        'username': session.get('username')
    })

# Configuration Routes
@app.route('/api/config', methods=['GET'])
@require_auth
def get_config():
    """Get current configuration"""
    try:
        config = serversh.load_env_config()
        return jsonify({'config': config})
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/config', methods=['POST'])
@require_auth
def save_config():
    """Save configuration"""
    try:
        data = request.get_json()
        config = data.get('config', {})

        if serversh.save_env_config(config):
            return jsonify({'success': True, 'message': 'Configuration saved successfully'})
        else:
            return jsonify({'error': 'Failed to save configuration'}), 500

    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/config/validate', methods=['POST'])
@require_auth
def validate_config():
    """Validate configuration"""
    try:
        data = request.get_json()
        config = data.get('config', {})

        # Basic validation
        errors = []

        # Check required fields
        required_fields = ['SERVERSH_HOSTNAME', 'SERVERSH_USERNAME', 'SERVERSH_USER_PASSWORD']
        for field in required_fields:
            if field not in config or not config[field]:
                errors.append(f'{field} is required')

        # Validate hostname
        if 'SERVERSH_HOSTNAME' in config:
            hostname = config['SERVERSH_HOSTNAME']
            if not hostname or len(hostname) > 63 or not hostname.replace('-', '').replace('_', '').isalnum():
                errors.append('Invalid hostname format')

        # Validate password strength
        if 'SERVERSH_USER_PASSWORD' in config:
            password = config['SERVERSH_USER_PASSWORD']
            if len(password) < 8:
                errors.append('Password must be at least 8 characters long')

        # Validate ports
        port_fields = ['SERVERSH_SSH_PORT', 'SERVERSH_PROMETHEUS_PORT', 'SERVERSH_NODE_EXPORTER_PORT']
        for field in port_fields:
            if field in config and config[field]:
                try:
                    port = int(config[field])
                    if port < 1 or port > 65535:
                        errors.append(f'{field} must be between 1 and 65535')
                except ValueError:
                    errors.append(f'{field} must be a valid port number')

        return jsonify({
            'valid': len(errors) == 0,
            'errors': errors
        })

    except Exception as e:
        return jsonify({'error': str(e)}), 500

# Module Routes
@app.route('/api/modules', methods=['GET'])
@require_auth
def get_modules():
    """Get available modules"""
    try:
        modules = serversh.get_modules()
        return jsonify({'modules': modules})
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/modules/<module_name>/execute', methods=['POST'])
@require_auth
def execute_module(module_name):
    """Execute module action"""
    try:
        data = request.get_json()
        action = data.get('action', 'install')
        config = data.get('config', {})

        result = serversh.execute_module(module_name, action, config)
        return jsonify(result)

    except Exception as e:
        return jsonify({'error': str(e)}), 500

# System Routes
@app.route('/api/system/info', methods=['GET'])
@require_auth
def get_system_info():
    """Get system information"""
    try:
        info = serversh.get_system_info()
        return jsonify(info)
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/system/status', methods=['GET'])
@require_auth
def get_system_status():
    """Get system status"""
    try:
        # Check critical services
        services = ['ssh', 'docker', 'prometheus', 'node_exporter']
        service_status = {}

        for service in services:
            try:
                result = subprocess.run(
                    ['systemctl', 'is-active', service],
                    capture_output=True,
                    text=True
                )
                service_status[service] = result.stdout.strip()
            except:
                service_status[service] = 'unknown'

        # Check ServerSH installation
        serversh_status = 'unknown'
        try:
            result = subprocess.run(
                [f'{SERVERSH_ROOT_DIR}/serversh/scripts/status.sh'],
                capture_output=True,
                text=True,
                cwd=SERVERSH_ROOT_DIR
            )
            if result.returncode == 0:
                serversh_status = 'installed'
        except:
            pass

        return jsonify({
            'services': service_status,
            'serversh_status': serversh_status,
            'timestamp': datetime.now().isoformat()
        })

    except Exception as e:
        return jsonify({'error': str(e)}), 500

# SSH Key Management Routes
@app.route('/api/ssh/keys', methods=['GET'])
@require_auth
def get_ssh_keys():
    """Get SSH keys"""
    try:
        username = serversh.load_env_config().get('SERVERSH_USERNAME', 'admin')
        ssh_dir = Path(f'/home/{username}/.ssh')

        keys = {}

        # Public key
        public_key_file = ssh_dir / 'id_rsa.pub'
        if public_key_file.exists():
            keys['public'] = public_key_file.read_text().strip()

        # Private key info (don't return the key itself)
        private_key_file = ssh_dir / 'id_rsa'
        if private_key_file.exists():
            keys['private_exists'] = True
            keys['private_type'] = 'rsa'
        else:
            keys['private_exists'] = False

        # Authorized keys
        authorized_keys_file = ssh_dir / 'authorized_keys'
        if authorized_keys_file.exists():
            keys['authorized_keys'] = authorized_keys_file.read_text().strip().split('\n')

        return jsonify({'keys': keys})

    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/ssh/keys/generate', methods=['POST'])
@require_auth
def generate_ssh_keys():
    """Generate new SSH keys"""
    try:
        data = request.get_json()
        key_type = data.get('type', 'ed25519')
        comment = data.get('comment', f'serversh-{datetime.now().strftime("%Y%m%d")}')

        username = serversh.load_env_config().get('SERVERSH_USERNAME', 'admin')
        ssh_dir = Path(f'/home/{username}/.ssh')

        # Create .ssh directory
        ssh_dir.mkdir(exist_ok=True, mode=0o700)

        # Generate new key pair
        key_file = ssh_dir / f'id_{key_type}'

        result = subprocess.run(
            ['ssh-keygen', '-t', key_type, '-f', str(key_file), '-N', '', '-C', comment],
            capture_output=True,
            text=True
        )

        if result.returncode != 0:
            return jsonify({'error': 'Failed to generate SSH keys', 'details': result.stderr}), 500

        # Set proper permissions
        key_file.chmod(0o600)
        key_file.with_suffix('.pub').chmod(0o644)

        # Add to authorized_keys
        authorized_keys_file = ssh_dir / 'authorized_keys'
        public_key = key_file.with_suffix('.pub').read_text().strip()

        if authorized_keys_file.exists():
            authorized_keys = authorized_keys_file.read_text().strip().split('\n')
            if public_key not in authorized_keys:
                authorized_keys.append(public_key)
                authorized_keys_file.write_text('\n'.join(authorized_keys) + '\n')
        else:
            authorized_keys_file.write_text(public_key + '\n')

        authorized_keys_file.chmod(0o600)

        # Change ownership
        subprocess.run(['chown', '-R', f'{username}:{username}', str(ssh_dir)])

        return jsonify({
            'success': True,
            'message': 'SSH keys generated successfully',
            'public_key': public_key
        })

    except Exception as e:
        return jsonify({'error': str(e)}), 500

@app.route('/api/ssh/keys/download/<format>', methods=['GET'])
@require_auth
def download_ssh_key(format):
    """Download SSH key in different formats"""
    try:
        username = serversh.load_env_config().get('SERVERSH_USERNAME', 'admin')
        ssh_dir = Path(f'/home/{username}/.ssh')

        if format == 'openssh':
            # Return OpenSSH format
            private_key_file = ssh_dir / 'id_rsa'
            if not private_key_file.exists():
                return jsonify({'error': 'Private key not found'}), 404

            return send_file(
                private_key_file,
                as_attachment=True,
                download_name=f'id_rsa_{username}.pem',
                mimetype='text/plain'
            )

        elif format == 'putty':
            # Convert to PuTTY format (would require puttygen)
            return jsonify({'error': 'PuTTY format not implemented yet'}), 501

        elif format == 'json':
            # Return JSON with metadata
            private_key_file = ssh_dir / 'id_rsa'
            public_key_file = ssh_dir / 'id_rsa.pub'

            if not private_key_file.exists():
                return jsonify({'error': 'Private key not found'}), 404

            key_data = {
                'private_key': private_key_file.read_text(),
                'public_key': public_key_file.read_text().strip(),
                'format': 'openssh',
                'type': 'rsa',
                'comment': f'serversh-key-{datetime.now().strftime("%Y%m%d")}',
                'generated_at': datetime.now().isoformat(),
                'username': username
            }

            return jsonify(key_data)

        else:
            return jsonify({'error': 'Unsupported format'}), 400

    except Exception as e:
        return jsonify({'error': str(e)}), 500

# Web UI Routes
@app.route('/')
def index():
    """Serve main web interface"""
    if 'authenticated' not in session:
        return render_template('login.html')
    return render_template('dashboard.html')

@app.route('/login')
def login_page():
    """Serve login page"""
    return render_template('login.html')

@app.route('/dashboard')
@require_auth
def dashboard():
    """Serve dashboard page"""
    return render_template('dashboard.html')

@app.route('/modules')
@require_auth
def modules_page():
    """Serve modules page"""
    return render_template('modules.html')

@app.route('/config')
@require_auth
def config_page():
    """Serve configuration page"""
    return render_template('config.html')

@app.route('/ssh')
@require_auth
def ssh_page():
    """Serve SSH management page"""
    return render_template('ssh.html')

if __name__ == '__main__':
    print("Starting ServerSH Web UI Server...")
    print(f"ServerSH Root: {SERVERSH_ROOT_DIR}")
    print(f"Config Directory: {SERVERSH_CONFIG_DIR}")
    print(f"Environment File: {ENV_FILE}")

    # Ensure log directory exists
    os.makedirs('/var/log/serversh', exist_ok=True)

    # Run the application
    app.run(
        host='0.0.0.0',
        port=8080,
        debug=False,
        ssl_context=None  # Can be configured for HTTPS
    )